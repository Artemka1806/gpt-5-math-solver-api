<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Math Solver WebSocket Client</title>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.css" integrity="sha384-GvrOXuhMATgEsSwCs4smul74iXGOixntILdUW9XmUC6+HX0sLNAK3q71HotJqlAn" crossorigin="anonymous">
  <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.js" integrity="sha384-cpW21h6RZv/phavutF+AuVYrr+dA8xD9zs6FwLpaCct6O9ctzYFfFr4dgmgccOTx" crossorigin="anonymous"></script>
  <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/contrib/auto-render.min.js" integrity="sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05" crossorigin="anonymous"></script>
  <style>
    body { font-family: Arial, sans-serif; margin: 2rem; }
    #output { 
      white-space: pre-wrap; 
      border: 1px solid #ccc; 
      padding: 1rem; 
      height: 500px; 
      overflow-y: auto; 
      line-height: 1.6;
    }
    .image-section { display: flex; align-items: flex-start; gap: 1rem; margin: 1rem 0; }
    .image-preview { max-width: 200px; max-height: 200px; border: 1px solid #ccc; border-radius: 4px; display: none; }
    .katex { font-size: 1.1em; }
    .math-expression { 
      background-color: #f8f9fa; 
      padding: 0.2em 0.4em; 
      border-radius: 3px; 
      margin: 0.1em 0;
      display: inline-block;
    }
  </style>
</head>
<body>
  <h1>WebSocket Math Solver</h1>
  <label>
    Access Token:
    <input type="text" id="token" size="60" />
  </label>
  <br /><br />
  <div class="image-section">
    <label>
      Image:
      <input type="file" id="image" accept="image/*" />
    </label>
    <img id="imagePreview" class="image-preview" alt="Image preview" />
  </div>
  <br /><br />
  <button id="connectBtn">Connect</button>
  <button id="sendBtn" disabled>Send</button>
  <button id="disconnectBtn" disabled>Disconnect</button>
  <button id="clearBtn">Clear Output</button>
  <button id="testBtn">Test LaTeX Parsing</button>
  <h2>Output</h2>
  <div id="output"></div>

  <script>
    let ws;
    let currentMessage = '';
    let messageTimeout = null;

    function renderLatex(text) {
      // Очищаємо текст від зайвих символів та нормалізуємо
      text = text.replace(/[\u200B-\u200D\uFEFF]/g, ''); // Видаляємо zero-width символи
      text = text.replace(/\r\n/g, '\n').replace(/\r/g, '\n'); // Нормалізуємо переноси рядків
      
      // Парсинг display math виразів ($$...$$) - спочатку обробляємо довгі формати
      text = text.replace(/\$\$([^$]+?)\$\$/g, (match, latex) => {
        try {
          const cleanLatex = latex.trim();
          return katex.renderToString(cleanLatex, {displayMode: true, throwOnError: false, fleqn: true});
        } catch (e) {
          console.log('LaTeX error ($$):', e.message, 'for:', latex);
          return match;
        }
      });
      
      // Парсинг LaTeX display блоків \[...\]
      text = text.replace(/\\\[([^\]]+?)\\\]/g, (match, latex) => {
        try {
          const cleanLatex = latex.trim();
          return katex.renderToString(cleanLatex, {displayMode: true, throwOnError: false, fleqn: true});
        } catch (e) {
          console.log('LaTeX error (\\[\\]):', e.message, 'for:', latex);
          return match;
        }
      });
      
      // Парсинг LaTeX inline блоків \(...\) з більш гнучким регексом
      text = text.replace(/\\\(([^)]+?)\\\)/g, (match, latex) => {
        try {
          const cleanLatex = latex.trim();
          return katex.renderToString(cleanLatex, {displayMode: false, throwOnError: false});
        } catch (e) {
          console.log('LaTeX error (\\(\\)):', e.message, 'for:', latex);
          return match;
        }
      });
      
      // Парсинг inline math виразів ($...$) - останніми, щоб не конфліктувати з $$
      text = text.replace(/(?<!\$)\$([^$\n]+?)\$(?!\$)/g, (match, latex) => {
        try {
          const cleanLatex = latex.trim();
          return katex.renderToString(cleanLatex, {displayMode: false, throwOnError: false});
        } catch (e) {
          console.log('LaTeX error ($):', e.message, 'for:', latex);
          return match;
        }
      });
      
      return text;
    }

    function appendOutput(text) {
      const output = document.getElementById('output');
      
      // Створюємо div для тексту
      const tempDiv = document.createElement('div');
      tempDiv.innerHTML = renderLatex(text);
      
      // Альтернативний метод: використовуємо auto-render для додаткової обробки
      try {
        if (window.renderMathInElement) {
          renderMathInElement(tempDiv, {
            delimiters: [
              {left: '$$', right: '$$', display: true},
              {left: '$', right: '$', display: false},
              {left: '\\[', right: '\\]', display: true},
              {left: '\\(', right: '\\)', display: false}
            ],
            throwOnError: false,
            errorColor: '#cc0000',
            strict: false,
            fleqn: true
          });
        }
      } catch (e) {
        console.log('Auto-render error:', e);
      }
      
      // Додаємо текст з рендерованими LaTeX виразами
      output.appendChild(tempDiv);
      output.scrollTop = output.scrollHeight;
    }

    function appendOutputRaw(text) {
      const output = document.getElementById('output');
      
      // Створюємо тимчасовий div для рендерингу тексту без LaTeX парсингу
      const tempDiv = document.createElement('div');
      tempDiv.textContent = text;
      
      // Додаємо простий текст
      output.appendChild(tempDiv);
      output.scrollTop = output.scrollHeight;
    }

    function processAccumulatedMessage() {
      if (currentMessage.trim()) {
        // Очищаємо попередній raw текст, якщо він був
        const output = document.getElementById('output');
        const lastChild = output.lastElementChild;
        if (lastChild && lastChild.classList.contains('raw-message')) {
          output.removeChild(lastChild);
        }
        
        // Дебаг: виводимо в консоль необроблений текст для аналізу
        console.log('Original message:', JSON.stringify(currentMessage));
        
        // Показуємо коди символів для проблемних місць
        const latexMatches = currentMessage.match(/\\\([^)]*\\\)/g);
        if (latexMatches) {
          latexMatches.forEach((match, index) => {
            console.log(`LaTeX match ${index}:`, JSON.stringify(match));
            for (let i = 0; i < match.length; i++) {
              const char = match[i];
              const code = char.charCodeAt(0);
              if (code > 127 || code < 32) {
                console.log(`Special char at pos ${i}: "${char}" (code: ${code})`);
              }
            }
          });
        }
        
        // Додаємо оброблене повідомлення з LaTeX
        appendOutput(currentMessage);
        currentMessage = '';
      }
    }

    // Handle image preview
    document.getElementById('image').onchange = (event) => {
      const file = event.target.files[0];
      const preview = document.getElementById('imagePreview');
      
      if (file) {
        const reader = new FileReader();
        reader.onload = (e) => {
          preview.src = e.target.result;
          preview.style.display = 'block';
        };
        reader.readAsDataURL(file);
      } else {
        preview.style.display = 'none';
        preview.src = '';
      }
    };

    document.getElementById('connectBtn').onclick = () => {
      const token = document.getElementById('token').value.trim();
      if (!token) {
        alert('Please provide an access token');
        return;
      }
      ws = new WebSocket(`ws://localhost:8000/ws/calculate?token=${encodeURIComponent(token)}`);
      ws.onopen = () => {
        appendOutput('\n[connected]\n');
        document.getElementById('sendBtn').disabled = false;
        document.getElementById('disconnectBtn').disabled = false;
        currentMessage = '';
      };
      ws.onmessage = (event) => {
        const data = event.data;
        
        // Перевіряємо чи це службове повідомлення
        if (data === '[DONE]') {
          processAccumulatedMessage();
          return;
        }
        
        // Накопичуємо символи
        currentMessage += data;
        
        // Відображаємо накопичений текст в реальному часі (без LaTeX парсингу)
        const output = document.getElementById('output');
        let lastRawDiv = output.lastElementChild;
        
        if (!lastRawDiv || !lastRawDiv.classList.contains('raw-message')) {
          lastRawDiv = document.createElement('div');
          lastRawDiv.classList.add('raw-message');
          lastRawDiv.style.fontFamily = 'monospace';
          lastRawDiv.style.color = '#666';
          output.appendChild(lastRawDiv);
        }
        
        lastRawDiv.textContent = currentMessage;
        output.scrollTop = output.scrollHeight;
        
        // Скидаємо таймер і встановлюємо новий
        if (messageTimeout) {
          clearTimeout(messageTimeout);
        }
        
        // Якщо протягом 1 секунди не було нових символів, обробляємо повідомлення
        messageTimeout = setTimeout(() => {
          processAccumulatedMessage();
        }, 1000);
      };
      ws.onerror = (err) => {
        appendOutput('\nERROR: ' + err.message + '\n');
        currentMessage = '';
      };
      ws.onclose = () => {
        if (currentMessage.trim()) {
          processAccumulatedMessage();
        }
        appendOutput('\n[disconnected]\n');
        document.getElementById('sendBtn').disabled = true;
        document.getElementById('disconnectBtn').disabled = true;
        currentMessage = '';
      };
    };

    document.getElementById('sendBtn').onclick = async () => {
      const file = document.getElementById('image').files[0];
      if (!file) {
        alert('Please choose an image');
        return;
      }
      const reader = new FileReader();
      reader.onload = () => {
        const base64 = reader.result.split(',')[1];
        ws.send(JSON.stringify({ action: 'solve', image: base64 }));
      };
      reader.readAsDataURL(file);
      appendOutput('\n' + '[sending image]' + '\n');
    };

    document.getElementById('disconnectBtn').onclick = () => {
      if (ws) ws.close();
    };

    document.getElementById('clearBtn').onclick = () => {
      document.getElementById('output').innerHTML = '';
      currentMessage = '';
      if (messageTimeout) {
        clearTimeout(messageTimeout);
        messageTimeout = null;
      }
    };

    document.getElementById('testBtn').onclick = () => {
      const testText = `Розглянемо ряд $\\sum_{n=1}^{\\infty} \\frac{(-1)^{n+1}}{\\ln(n + 1)}$.

1) Збіжність за ознакою Лейбніца.
- Покладемо \\(b_n=\\frac{1}{\\ln(n+1)}\\). Маємо $b_n > 0$ для всіх $n \\geq 1$.
- Оскільки \\(\\ln(n+1)\\) зростає, то $b_{n+1} < b_n$, тобто $\\{b_n\\}$ спадна.
- \\(\\displaystyle \\lim_{n\\to\\infty} b_n=\\lim_{n\\to\\infty}\\frac{1}{\\ln(n+1)}=0\\).

Отже, за ознакою Лейбніца ряд збігається.

2) Перевірка абсолютної збіжності.`;
      
      appendOutput(testText);
    };
  </script>
</body>
</html>
