<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Math Solver WebSocket Client</title>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.css" integrity="sha384-GvrOXuhMATgEsSwCs4smul74iXGOixntILdUW9XmUC6+HX0sLNAK3q71HotJqlAn" crossorigin="anonymous">
  <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.js" integrity="sha384-cpW21h6RZv/phavutF+AuVYrr+dA8xD9zs6FwLpaCct6O9ctzYFfFr4dgmgccOTx" crossorigin="anonymous"></script>
  <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/contrib/auto-render.min.js" integrity="sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05" crossorigin="anonymous"></script>
  <script src="https://accounts.google.com/gsi/client" async></script>

  <style>
    body { font-family: Arial, sans-serif; margin: 2rem; }
    #output { 
      white-space: pre-wrap; 
      border: 1px solid #ccc; 
      padding: 1rem; 
      height: 500px; 
      overflow-y: auto; 
      line-height: 1.6;
    }
    .image-section { display: flex; align-items: flex-start; gap: 1rem; margin: 1rem 0; }
    .image-preview { max-width: 200px; max-height: 200px; border: 1px solid #ccc; border-radius: 4px; display: none; }
    .katex { font-size: 1.1em; }
    .math-expression { 
      background-color: #f8f9fa; 
      padding: 0.2em 0.4em; 
      border-radius: 3px; 
      margin: 0.1em 0;
      display: inline-block;
    }
    .formatted-latex {
      color: #000;
      font-family: Arial, sans-serif;
    }
    .raw-message {
      transition: all 0.3s ease;
      font-family: Arial, sans-serif !important;
      color: #000 !important;
      line-height: 1.6;
    }
    .g_id_signin {
      margin: 10px;
    }
  </style>
</head>
<body>
  <h1>WebSocket Math Solver</h1>
  <html>
  <body>
    <div id="g_id_onload"
     data-client_id="813983322760-oe9ujgssrqdh9e8kvg4kcgpatok4o449.apps.googleusercontent.com"
     data-context="signin"
     data-ux_mode="popup"
     data-login_uri="https://gpt-math-solver.artemka1806.dev/auth/google-login"
     data-auto_prompt="false">
</div>

<div class="g_id_signin"
     data-type="standard"
     data-shape="rectangular"
     data-theme="outline"
     data-text="signin_with"
     data-size="large"
     data-logo_alignment="left">
</div>
  <body>
</html>

  <label>
    Access Token:
    <input type="text" id="token" size="60" />
  </label>
  <br /><br />
  <label>
    Refresh Token:
    <input type="text" id="refreshToken" size="60" />
  </label>
  <br /><br />
  <div class="image-section">
    <label>
      Image:
      <input type="file" id="image" accept="image/*" />
    </label>
    <img id="imagePreview" class="image-preview" alt="Image preview" />
  </div>
  <br /><br />
  <button id="connectBtn">Connect</button>
  <button id="sendBtn" disabled>Send</button>
  <button id="disconnectBtn" disabled>Disconnect</button>
  <button id="clearBtn">Clear Output</button>
  <button id="testBtn">Test LaTeX Parsing</button>
  <h2>Output</h2>
  <div id="output"></div>

  <script>
    let ws;
    let currentMessage = '';
    let messageTimeout = null;

    function getTokenFromUrlOrStorage(parameterName) {
      const urlParams = new URLSearchParams(window.location.search);
      let tokenValue = urlParams.get(parameterName);
      if (tokenValue && tokenValue.length > 0) {
        try {
          localStorage.setItem(parameterName, tokenValue);
        } catch (_) {
          // Ignore storage failures (e.g., Safari private mode)
        }
      } else {
        try {
          tokenValue = localStorage.getItem(parameterName) || '';
        } catch (_) {
          tokenValue = '';
        }
      }
      return tokenValue;
    }

    // Populate inputs from URL parameters or localStorage
    (function initializeTokens() {
      const accessToken = getTokenFromUrlOrStorage('accessToken');
      const refreshToken = getTokenFromUrlOrStorage('refreshToken');
      const accessInput = document.getElementById('token');
      const refreshInput = document.getElementById('refreshToken');
      if (accessInput && accessToken) accessInput.value = accessToken;
      if (refreshInput && refreshToken) refreshInput.value = refreshToken;
    })();

    function renderLatex(text) {
      // Очищаємо текст від зайвих символів та нормалізуємо
      text = text.replace(/[\u200B-\u200D\uFEFF]/g, ''); // Видаляємо zero-width символи
      text = text.replace(/\r\n/g, '\n').replace(/\r/g, '\n'); // Нормалізуємо переноси рядків
      
      // Парсинг display math виразів ($$...$$) - спочатку обробляємо довгі формати
      text = text.replace(/\$\$([^$]+?)\$\$/g, (match, latex) => {
        try {
          const cleanLatex = latex.trim();
          return katex.renderToString(cleanLatex, {displayMode: true, throwOnError: false, fleqn: true});
        } catch (e) {
          console.log('LaTeX error ($$):', e.message, 'for:', latex);
          return match;
        }
      });
      
      // Парсинг LaTeX display блоків \[...\]
      text = text.replace(/\\\[([^\]]+?)\\\]/g, (match, latex) => {
        try {
          const cleanLatex = latex.trim();
          return katex.renderToString(cleanLatex, {displayMode: true, throwOnError: false, fleqn: true});
        } catch (e) {
          console.log('LaTeX error (\\[\\]):', e.message, 'for:', latex);
          return match;
        }
      });
      
      // Парсинг LaTeX inline блоків \(...\) з більш гнучким регексом
      text = text.replace(/\\\(([^)]+?)\\\)/g, (match, latex) => {
        try {
          const cleanLatex = latex.trim();
          return katex.renderToString(cleanLatex, {displayMode: false, throwOnError: false});
        } catch (e) {
          console.log('LaTeX error (\\(\\)):', e.message, 'for:', latex);
          return match;
        }
      });
      
      // Парсинг inline math виразів ($...$) - останніми, щоб не конфліктувати з $$
      text = text.replace(/(?<!\$)\$([^$\n]+?)\$(?!\$)/g, (match, latex) => {
        try {
          const cleanLatex = latex.trim();
          return katex.renderToString(cleanLatex, {displayMode: false, throwOnError: false});
        } catch (e) {
          console.log('LaTeX error ($):', e.message, 'for:', latex);
          return match;
        }
      });
      
      return text;
    }

    function appendOutput(text) {
      const output = document.getElementById('output');
      
      // Створюємо div для тексту
      const tempDiv = document.createElement('div');
      tempDiv.innerHTML = renderLatex(text);
      
      // Альтернативний метод: використовуємо auto-render для додаткової обробки
      try {
        if (window.renderMathInElement) {
          renderMathInElement(tempDiv, {
            delimiters: [
              {left: '$$', right: '$$', display: true},
              {left: '$', right: '$', display: false},
              {left: '\\[', right: '\\]', display: true},
              {left: '\\(', right: '\\)', display: false}
            ],
            throwOnError: false,
            errorColor: '#cc0000',
            strict: false,
            fleqn: true
          });
        }
      } catch (e) {
        console.log('Auto-render error:', e);
      }
      
      // Додаємо текст з рендерованими LaTeX виразами
      output.appendChild(tempDiv);
      output.scrollTop = output.scrollHeight;
    }

    function appendOutputRaw(text) {
      const output = document.getElementById('output');
      
      // Створюємо тимчасовий div для рендерингу тексту без LaTeX парсингу
      const tempDiv = document.createElement('div');
      tempDiv.textContent = text;
      
      // Додаємо простий текст
      output.appendChild(tempDiv);
      output.scrollTop = output.scrollHeight;
    }

    function tryFormatCompleteFormulas() {
      // Шукаємо завершені формули та форматуємо їх
      let hasChanges = false;
      let workingMessage = currentMessage;
      
      // Спочатку обробляємо display формули $$...$$
      workingMessage = workingMessage.replace(/\$\$([^$]+?)\$\$/g, (match, latex) => {
        try {
          const cleanLatex = latex.trim();
          hasChanges = true;
          return '<span class="formatted-latex">' + katex.renderToString(cleanLatex, {displayMode: true, throwOnError: false, fleqn: true}) + '</span>';
        } catch (e) {
          return match;
        }
      });
      
      // LaTeX display блоки \[...\]
      workingMessage = workingMessage.replace(/\\\[([^\]]+?)\\\]/g, (match, latex) => {
        try {
          const cleanLatex = latex.trim();
          hasChanges = true;
          return '<span class="formatted-latex">' + katex.renderToString(cleanLatex, {displayMode: true, throwOnError: false, fleqn: true}) + '</span>';
        } catch (e) {
          return match;
        }
      });
      
      // LaTeX inline блоки \(...\)
      workingMessage = workingMessage.replace(/\\\(([^)]+?)\\\)/g, (match, latex) => {
        try {
          const cleanLatex = latex.trim();
          hasChanges = true;
          return '<span class="formatted-latex">' + katex.renderToString(cleanLatex, {displayMode: false, throwOnError: false}) + '</span>';
        } catch (e) {
          return match;
        }
      });
      
      // Inline формули $...$
      workingMessage = workingMessage.replace(/(?<!\$)\$([^$\n]+?)\$(?!\$)/g, (match, latex) => {
        try {
          const cleanLatex = latex.trim();
          hasChanges = true;
          return '<span class="formatted-latex">' + katex.renderToString(cleanLatex, {displayMode: false, throwOnError: false}) + '</span>';
        } catch (e) {
          return match;
        }
      });
      
      return { formattedMessage: workingMessage, hasChanges };
    }

    function processAccumulatedMessage() {
      if (currentMessage.trim()) {
        // Очищаємо попередній raw текст, якщо він був
        const output = document.getElementById('output');
        const lastChild = output.lastElementChild;
        if (lastChild && lastChild.classList.contains('raw-message')) {
          output.removeChild(lastChild);
        }
        
        // Пробуємо форматувати завершені формули
        const { formattedMessage } = tryFormatCompleteFormulas();
        
        // Створюємо div для остаточного тексту
        const finalDiv = document.createElement('div');
        finalDiv.innerHTML = formattedMessage;
        
        // Додаємо текст з рендерованими LaTeX виразами
        output.appendChild(finalDiv);
        output.scrollTop = output.scrollHeight;
        currentMessage = '';
      }
    }

    // Handle image preview
    document.getElementById('image').onchange = (event) => {
      const file = event.target.files[0];
      const preview = document.getElementById('imagePreview');
      
      if (file) {
        const reader = new FileReader();
        reader.onload = (e) => {
          preview.src = e.target.result;
          preview.style.display = 'block';
        };
        reader.readAsDataURL(file);
      } else {
        preview.style.display = 'none';
        preview.src = '';
      }
    };

    document.getElementById('connectBtn').onclick = () => {
      const token = document.getElementById('token').value.trim();
      if (!token) {
        alert('Please provide an access token');
        return;
      }
      ws = new WebSocket(`wss://gpt-math-solver.artemka1806.dev/ws/calculate?token=${encodeURIComponent(token)}`);
      ws.onopen = () => {
        appendOutput('\n[connected]\n');
        document.getElementById('sendBtn').disabled = false;
        document.getElementById('disconnectBtn').disabled = false;
        currentMessage = '';
      };
      ws.onmessage = (event) => {
        const data = event.data;
        
        // Перевіряємо чи це службове повідомлення
        if (data === '[DONE]') {
          processAccumulatedMessage();
          return;
        }
        
        // Накопичуємо символи
        currentMessage += data;
        
        // Відображаємо накопичений текст в реальному часі
        const output = document.getElementById('output');
        let lastRawDiv = output.lastElementChild;
        
        if (!lastRawDiv || !lastRawDiv.classList.contains('raw-message')) {
          lastRawDiv = document.createElement('div');
          lastRawDiv.classList.add('raw-message');
          output.appendChild(lastRawDiv);
        }
        
        // Пробуємо форматувати завершені формули
        const { formattedMessage, hasChanges } = tryFormatCompleteFormulas();
        
        if (hasChanges) {
          // Якщо є сформатовані формули, показуємо форматований текст
          lastRawDiv.innerHTML = formattedMessage;
        } else {
          // Інакше показуємо простий текст
          lastRawDiv.textContent = currentMessage;
        }
        
        output.scrollTop = output.scrollHeight;
        
        // Скидаємо таймер і встановлюємо новий
        if (messageTimeout) {
          clearTimeout(messageTimeout);
        }
        
        // Якщо протягом 1 секунди не було нових символів, обробляємо повідомлення
        messageTimeout = setTimeout(() => {
          processAccumulatedMessage();
        }, 1000);
      };
      ws.onerror = (err) => {
        appendOutput('\nERROR: ' + err.message + '\n');
        currentMessage = '';
      };
      ws.onclose = () => {
        if (currentMessage.trim()) {
          processAccumulatedMessage();
        }
        appendOutput('\n[disconnected]\n');
        document.getElementById('sendBtn').disabled = true;
        document.getElementById('disconnectBtn').disabled = true;
        currentMessage = '';
      };
    };

    document.getElementById('sendBtn').onclick = async () => {
      const file = document.getElementById('image').files[0];
      if (!file) {
        alert('Please choose an image');
        return;
      }
      const reader = new FileReader();
      reader.onload = () => {
        const base64 = reader.result.split(',')[1];
        ws.send(JSON.stringify({ action: 'solve', image: base64 }));
      };
      reader.readAsDataURL(file);
      appendOutput('\n' + '[sending image]' + '\n');
    };

    document.getElementById('disconnectBtn').onclick = () => {
      if (ws) ws.close();
    };

    document.getElementById('clearBtn').onclick = () => {
      document.getElementById('output').innerHTML = '';
      currentMessage = '';
      if (messageTimeout) {
        clearTimeout(messageTimeout);
        messageTimeout = null;
      }
    };

    document.getElementById('testBtn').onclick = () => {
      const testText = `Розглянемо ряд $\\sum_{n=1}^{\\infty} \\frac{(-1)^{n+1}}{\\ln(n + 1)}$.

1) Збіжність за ознакою Лейбніца.
- Покладемо \\(b_n=\\frac{1}{\\ln(n+1)}\\). Маємо $b_n > 0$ для всіх $n \\geq 1$.
- Оскільки \\(\\ln(n+1)\\) зростає, то $b_{n+1} < b_n$, тобто $\\{b_n\\}$ спадна.
- \\(\\displaystyle \\lim_{n\\to\\infty} b_n=\\lim_{n\\to\\infty}\\frac{1}{\\ln(n+1)}=0\\).

Отже, за ознакою Лейбніца ряд збігається.

2) Перевірка абсолютної збіжності.`;
      
      appendOutput(testText);
    };
  </script>
</body>
</html>
